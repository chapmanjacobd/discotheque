// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const addPlaylistItem = `-- name: AddPlaylistItem :exec
INSERT INTO playlist_items (playlist_id, media_path, track_number, time_added)
VALUES (?, ?, ?, strftime('%s', 'now'))
ON CONFLICT(playlist_id, media_path) DO UPDATE SET
    track_number = excluded.track_number
`

type AddPlaylistItemParams struct {
	PlaylistID  int64         `json:"playlist_id"`
	MediaPath   string        `json:"media_path"`
	TrackNumber sql.NullInt64 `json:"track_number"`
}

func (q *Queries) AddPlaylistItem(ctx context.Context, arg AddPlaylistItemParams) error {
	_, err := q.db.ExecContext(ctx, addPlaylistItem, arg.PlaylistID, arg.MediaPath, arg.TrackNumber)
	return err
}

const clearPlaylist = `-- name: ClearPlaylist :exec
DELETE FROM playlist_items WHERE playlist_id = ?
`

func (q *Queries) ClearPlaylist(ctx context.Context, playlistID int64) error {
	_, err := q.db.ExecContext(ctx, clearPlaylist, playlistID)
	return err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
UPDATE playlists SET time_deleted = ? WHERE id = ?
`

type DeletePlaylistParams struct {
	TimeDeleted sql.NullInt64 `json:"time_deleted"`
	ID          int64         `json:"id"`
}

func (q *Queries) DeletePlaylist(ctx context.Context, arg DeletePlaylistParams) error {
	_, err := q.db.ExecContext(ctx, deletePlaylist, arg.TimeDeleted, arg.ID)
	return err
}

const getAllMediaMetadata = `-- name: GetAllMediaMetadata :many
SELECT path, size, time_modified, time_deleted FROM media
`

type GetAllMediaMetadataRow struct {
	Path         string        `json:"path"`
	Size         sql.NullInt64 `json:"size"`
	TimeModified sql.NullInt64 `json:"time_modified"`
	TimeDeleted  sql.NullInt64 `json:"time_deleted"`
}

func (q *Queries) GetAllMediaMetadata(ctx context.Context) ([]GetAllMediaMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMediaMetadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMediaMetadataRow{}
	for rows.Next() {
		var i GetAllMediaMetadataRow
		if err := rows.Scan(
			&i.Path,
			&i.Size,
			&i.TimeModified,
			&i.TimeDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT 'sports' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;sports;%'
UNION ALL
SELECT 'fitness' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;fitness;%'
UNION ALL
SELECT 'documentary' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;documentary;%'
UNION ALL
SELECT 'comedy' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;comedy;%'
UNION ALL
SELECT 'music' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;music;%'
UNION ALL
SELECT 'educational' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;educational;%'
UNION ALL
SELECT 'news' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;news;%'
UNION ALL
SELECT 'gaming' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;gaming;%'
UNION ALL
SELECT 'tech' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;tech;%'
UNION ALL
SELECT 'audiobook' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND categories LIKE '%;audiobook;%'
UNION ALL
SELECT 'Uncategorized' as category, COUNT(*) as count FROM media WHERE time_deleted = 0 AND (categories IS NULL OR categories = '')
ORDER BY count DESC
`

type GetCategoryStatsRow struct {
	Category string `json:"category"`
	Count    int64  `json:"count"`
}

func (q *Queries) GetCategoryStats(ctx context.Context) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoryStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryStatsRow{}
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomCategories = `-- name: GetCustomCategories :many
SELECT DISTINCT category FROM custom_keywords
`

func (q *Queries) GetCustomCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCustomCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenreStats = `-- name: GetGenreStats :many
SELECT genre, COUNT(*) as count
FROM media
WHERE time_deleted = 0 AND genre IS NOT NULL AND genre != ''
GROUP BY genre
ORDER BY count DESC
`

type GetGenreStatsRow struct {
	Genre sql.NullString `json:"genre"`
	Count int64          `json:"count"`
}

func (q *Queries) GetGenreStats(ctx context.Context) ([]GetGenreStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGenreStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGenreStatsRow{}
	for rows.Next() {
		var i GetGenreStatsRow
		if err := rows.Scan(&i.Genre, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHistoryCount = `-- name: GetHistoryCount :one
SELECT COUNT(*) FROM history WHERE media_path = ?
`

func (q *Queries) GetHistoryCount(ctx context.Context, mediaPath string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHistoryCount, mediaPath)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMedia = `-- name: GetMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByDuration = `-- name: GetMediaByDuration :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND duration >= ?
  AND duration <= ?
ORDER BY duration DESC
LIMIT ?
`

type GetMediaByDurationParams struct {
	Duration   sql.NullInt64 `json:"duration"`
	Duration_2 sql.NullInt64 `json:"duration_2"`
	Limit      int64         `json:"limit"`
}

func (q *Queries) GetMediaByDuration(ctx context.Context, arg GetMediaByDurationParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByDuration, arg.Duration, arg.Duration_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPath = `-- name: GetMediaByPath :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND path LIKE ?
ORDER BY path
LIMIT ?
`

type GetMediaByPathParams struct {
	Path  string `json:"path"`
	Limit int64  `json:"limit"`
}

func (q *Queries) GetMediaByPath(ctx context.Context, arg GetMediaByPathParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPath, arg.Path, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPathExact = `-- name: GetMediaByPathExact :one
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE path = ?
LIMIT 1
`

func (q *Queries) GetMediaByPathExact(ctx context.Context, path string) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByPathExact, path)
	var i Media
	err := row.Scan(
		&i.Path,
		&i.Title,
		&i.Duration,
		&i.Size,
		&i.TimeCreated,
		&i.TimeModified,
		&i.TimeDeleted,
		&i.TimeFirstPlayed,
		&i.TimeLastPlayed,
		&i.PlayCount,
		&i.Playhead,
		&i.Type,
		&i.Width,
		&i.Height,
		&i.Fps,
		&i.VideoCodecs,
		&i.AudioCodecs,
		&i.SubtitleCodecs,
		&i.VideoCount,
		&i.AudioCount,
		&i.SubtitleCount,
		&i.Album,
		&i.Artist,
		&i.Genre,
		&i.Mood,
		&i.Bpm,
		&i.Key,
		&i.Decade,
		&i.Categories,
		&i.City,
		&i.Country,
		&i.Description,
		&i.Language,
		&i.Webpath,
		&i.Uploader,
		&i.TimeUploaded,
		&i.TimeDownloaded,
		&i.ViewCount,
		&i.NumComments,
		&i.FavoriteCount,
		&i.Score,
		&i.UpvoteRatio,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const getMediaByPlayCount = `-- name: GetMediaByPlayCount :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND play_count >= ?
  AND play_count <= ?
ORDER BY play_count DESC
LIMIT ?
`

type GetMediaByPlayCountParams struct {
	PlayCount   sql.NullInt64 `json:"play_count"`
	PlayCount_2 sql.NullInt64 `json:"play_count_2"`
	Limit       int64         `json:"limit"`
}

func (q *Queries) GetMediaByPlayCount(ctx context.Context, arg GetMediaByPlayCountParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPlayCount, arg.PlayCount, arg.PlayCount_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaBySize = `-- name: GetMediaBySize :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND size >= ?
  AND size <= ?
ORDER BY size DESC
LIMIT ?
`

type GetMediaBySizeParams struct {
	Size   sql.NullInt64 `json:"size"`
	Size_2 sql.NullInt64 `json:"size_2"`
	Limit  int64         `json:"limit"`
}

func (q *Queries) GetMediaBySize(ctx context.Context, arg GetMediaBySizeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaBySize, arg.Size, arg.Size_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByType = `-- name: GetMediaByType :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND (
    (? AND type = 'video')
    OR (? AND (type = 'audio' OR type = 'audiobook'))
    OR (? AND type = 'image')
  )
ORDER BY path
LIMIT ?
`

type GetMediaByTypeParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int64       `json:"limit"`
}

func (q *Queries) GetMediaByType(ctx context.Context, arg GetMediaByTypeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByType,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistItems = `-- name: GetPlaylistItems :many
SELECT m.path, m.title, m.duration, m.size, m.time_created, m.time_modified, m.time_deleted, m.time_first_played, m.time_last_played, m.play_count, m.playhead, m.type, m.width, m.height, m.fps, m.video_codecs, m.audio_codecs, m.subtitle_codecs, m.video_count, m.audio_count, m.subtitle_count, m.album, m.artist, m.genre, m.mood, m.bpm, m."key", m.decade, m.categories, m.city, m.country, m.description, m.language, m.webpath, m.uploader, m.time_uploaded, m.time_downloaded, m.view_count, m.num_comments, m.favorite_count, m.score, m.upvote_ratio, m.latitude, m.longitude, pi.track_number, pi.time_added FROM media m
JOIN playlist_items pi ON m.path = pi.media_path
WHERE pi.playlist_id = ? AND m.time_deleted = 0
ORDER BY pi.track_number, pi.time_added, m.path
`

type GetPlaylistItemsRow struct {
	Path            string          `json:"path"`
	Title           sql.NullString  `json:"title"`
	Duration        sql.NullInt64   `json:"duration"`
	Size            sql.NullInt64   `json:"size"`
	TimeCreated     sql.NullInt64   `json:"time_created"`
	TimeModified    sql.NullInt64   `json:"time_modified"`
	TimeDeleted     sql.NullInt64   `json:"time_deleted"`
	TimeFirstPlayed sql.NullInt64   `json:"time_first_played"`
	TimeLastPlayed  sql.NullInt64   `json:"time_last_played"`
	PlayCount       sql.NullInt64   `json:"play_count"`
	Playhead        sql.NullInt64   `json:"playhead"`
	Type            sql.NullString  `json:"type"`
	Width           sql.NullInt64   `json:"width"`
	Height          sql.NullInt64   `json:"height"`
	Fps             sql.NullFloat64 `json:"fps"`
	VideoCodecs     sql.NullString  `json:"video_codecs"`
	AudioCodecs     sql.NullString  `json:"audio_codecs"`
	SubtitleCodecs  sql.NullString  `json:"subtitle_codecs"`
	VideoCount      sql.NullInt64   `json:"video_count"`
	AudioCount      sql.NullInt64   `json:"audio_count"`
	SubtitleCount   sql.NullInt64   `json:"subtitle_count"`
	Album           sql.NullString  `json:"album"`
	Artist          sql.NullString  `json:"artist"`
	Genre           sql.NullString  `json:"genre"`
	Mood            sql.NullString  `json:"mood"`
	Bpm             sql.NullInt64   `json:"bpm"`
	Key             sql.NullString  `json:"key"`
	Decade          sql.NullString  `json:"decade"`
	Categories      sql.NullString  `json:"categories"`
	City            sql.NullString  `json:"city"`
	Country         sql.NullString  `json:"country"`
	Description     sql.NullString  `json:"description"`
	Language        sql.NullString  `json:"language"`
	Webpath         sql.NullString  `json:"webpath"`
	Uploader        sql.NullString  `json:"uploader"`
	TimeUploaded    sql.NullInt64   `json:"time_uploaded"`
	TimeDownloaded  sql.NullInt64   `json:"time_downloaded"`
	ViewCount       sql.NullInt64   `json:"view_count"`
	NumComments     sql.NullInt64   `json:"num_comments"`
	FavoriteCount   sql.NullInt64   `json:"favorite_count"`
	Score           sql.NullFloat64 `json:"score"`
	UpvoteRatio     sql.NullFloat64 `json:"upvote_ratio"`
	Latitude        sql.NullFloat64 `json:"latitude"`
	Longitude       sql.NullFloat64 `json:"longitude"`
	TrackNumber     sql.NullInt64   `json:"track_number"`
	TimeAdded       sql.NullInt64   `json:"time_added"`
}

func (q *Queries) GetPlaylistItems(ctx context.Context, playlistID int64) ([]GetPlaylistItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistItems, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistItemsRow{}
	for rows.Next() {
		var i GetPlaylistItemsRow
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
			&i.TrackNumber,
			&i.TimeAdded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylists = `-- name: GetPlaylists :many
SELECT id, path, title, extractor_key, extractor_config, time_deleted FROM playlists WHERE time_deleted = 0 ORDER BY title, path
`

func (q *Queries) GetPlaylists(ctx context.Context) ([]Playlists, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlists{}
	for rows.Next() {
		var i Playlists
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Title,
			&i.ExtractorKey,
			&i.ExtractorConfig,
			&i.TimeDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMedia = `-- name: GetRandomMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
ORDER BY RANDOM()
LIMIT ?
`

func (q *Queries) GetRandomMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getRandomMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingStats = `-- name: GetRatingStats :many
SELECT CAST(COALESCE(score, 0) AS INTEGER) as rating, COUNT(*) as count
FROM media
WHERE time_deleted = 0
GROUP BY rating
ORDER BY rating DESC
`

type GetRatingStatsRow struct {
	Rating int64 `json:"rating"`
	Count  int64 `json:"count"`
}

func (q *Queries) GetRatingStats(ctx context.Context) ([]GetRatingStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRatingStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingStatsRow{}
	for rows.Next() {
		var i GetRatingStatsRow
		if err := rows.Scan(&i.Rating, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiblingMedia = `-- name: GetSiblingMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND path LIKE ?
  AND path != ?
ORDER BY path
LIMIT ?
`

type GetSiblingMediaParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetSiblingMedia(ctx context.Context, arg GetSiblingMediaParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getSiblingMedia, arg.Path, arg.Path_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :one
SELECT
    COUNT(*) as total_count,
    SUM(size) as total_size,
    SUM(duration) as total_duration,
    COUNT(CASE WHEN COALESCE(time_last_played, 0) > 0 THEN 1 END) as watched_count,
    COUNT(CASE WHEN COALESCE(time_last_played, 0) = 0 THEN 1 END) as unwatched_count,
    SUM(COALESCE(play_count, 0) * COALESCE(duration, 0) + COALESCE(playhead, 0)) as total_watched_duration
FROM media
WHERE time_deleted = 0
`

type GetStatsRow struct {
	TotalCount           int64           `json:"total_count"`
	TotalSize            sql.NullFloat64 `json:"total_size"`
	TotalDuration        sql.NullFloat64 `json:"total_duration"`
	WatchedCount         int64           `json:"watched_count"`
	UnwatchedCount       int64           `json:"unwatched_count"`
	TotalWatchedDuration sql.NullFloat64 `json:"total_watched_duration"`
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.TotalSize,
		&i.TotalDuration,
		&i.WatchedCount,
		&i.UnwatchedCount,
		&i.TotalWatchedDuration,
	)
	return i, err
}

const getStatsByType = `-- name: GetStatsByType :many
SELECT
    type,
    COUNT(*) as count,
    SUM(size) as total_size,
    SUM(duration) as total_duration
FROM media
WHERE time_deleted = 0
GROUP BY type
`

type GetStatsByTypeRow struct {
	Type          sql.NullString  `json:"type"`
	Count         int64           `json:"count"`
	TotalSize     sql.NullFloat64 `json:"total_size"`
	TotalDuration sql.NullFloat64 `json:"total_duration"`
}

func (q *Queries) GetStatsByType(ctx context.Context) ([]GetStatsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatsByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatsByTypeRow{}
	for rows.Next() {
		var i GetStatsByTypeRow
		if err := rows.Scan(
			&i.Type,
			&i.Count,
			&i.TotalSize,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedMedia = `-- name: GetUnfinishedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND playhead > 0
  AND playhead < duration * 0.95
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetUnfinishedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnfinishedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnwatchedMedia = `-- name: GetUnwatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND COALESCE(time_last_played, 0) = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetUnwatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnwatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsedCategories = `-- name: GetUsedCategories :many
SELECT categories, COUNT(*) as count
FROM media
WHERE time_deleted = 0 AND categories IS NOT NULL AND categories != ''
GROUP BY categories
`

type GetUsedCategoriesRow struct {
	Categories sql.NullString `json:"categories"`
	Count      int64          `json:"count"`
}

func (q *Queries) GetUsedCategories(ctx context.Context) ([]GetUsedCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsedCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsedCategoriesRow{}
	for rows.Next() {
		var i GetUsedCategoriesRow
		if err := rows.Scan(&i.Categories, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedMedia = `-- name: GetWatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE time_deleted = 0
  AND COALESCE(time_last_played, 0) > 0
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetWatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCaption = `-- name: InsertCaption :exec
INSERT INTO captions (media_path, time, text)
VALUES (?, ?, ?)
`

type InsertCaptionParams struct {
	MediaPath string          `json:"media_path"`
	Time      sql.NullFloat64 `json:"time"`
	Text      sql.NullString  `json:"text"`
}

func (q *Queries) InsertCaption(ctx context.Context, arg InsertCaptionParams) error {
	_, err := q.db.ExecContext(ctx, insertCaption, arg.MediaPath, arg.Time, arg.Text)
	return err
}

const insertHistory = `-- name: InsertHistory :exec
INSERT INTO history (media_path, time_played, playhead, done)
VALUES (?, ?, ?, ?)
`

type InsertHistoryParams struct {
	MediaPath  string        `json:"media_path"`
	TimePlayed sql.NullInt64 `json:"time_played"`
	Playhead   sql.NullInt64 `json:"playhead"`
	Done       sql.NullInt64 `json:"done"`
}

func (q *Queries) InsertHistory(ctx context.Context, arg InsertHistoryParams) error {
	_, err := q.db.ExecContext(ctx, insertHistory,
		arg.MediaPath,
		arg.TimePlayed,
		arg.Playhead,
		arg.Done,
	)
	return err
}

const insertPlaylist = `-- name: InsertPlaylist :one
INSERT INTO playlists (path, title, extractor_key, extractor_config)
VALUES (?, ?, ?, ?)
ON CONFLICT(path) DO UPDATE SET
    title = COALESCE(excluded.title, playlists.title),
    extractor_key = excluded.extractor_key,
    extractor_config = excluded.extractor_config
RETURNING id
`

type InsertPlaylistParams struct {
	Path            sql.NullString `json:"path"`
	Title           sql.NullString `json:"title"`
	ExtractorKey    sql.NullString `json:"extractor_key"`
	ExtractorConfig sql.NullString `json:"extractor_config"`
}

func (q *Queries) InsertPlaylist(ctx context.Context, arg InsertPlaylistParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertPlaylist,
		arg.Path,
		arg.Title,
		arg.ExtractorKey,
		arg.ExtractorConfig,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const markDeleted = `-- name: MarkDeleted :exec
UPDATE media
SET time_deleted = ?
WHERE path = ?
`

type MarkDeletedParams struct {
	TimeDeleted sql.NullInt64 `json:"time_deleted"`
	Path        string        `json:"path"`
}

func (q *Queries) MarkDeleted(ctx context.Context, arg MarkDeletedParams) error {
	_, err := q.db.ExecContext(ctx, markDeleted, arg.TimeDeleted, arg.Path)
	return err
}

const removePlaylistItem = `-- name: RemovePlaylistItem :exec
DELETE FROM playlist_items WHERE playlist_id = ? AND media_path = ?
`

type RemovePlaylistItemParams struct {
	PlaylistID int64  `json:"playlist_id"`
	MediaPath  string `json:"media_path"`
}

func (q *Queries) RemovePlaylistItem(ctx context.Context, arg RemovePlaylistItemParams) error {
	_, err := q.db.ExecContext(ctx, removePlaylistItem, arg.PlaylistID, arg.MediaPath)
	return err
}

const searchCaptions = `-- name: SearchCaptions :many
SELECT c.media_path, c.time, c.text, m.title
FROM captions c
JOIN captions_fts f ON c.rowid = f.rowid
JOIN media m ON c.media_path = m.path
WHERE f.text MATCH ?1
  AND m.time_deleted = 0
ORDER BY c.media_path, c.time
`

type SearchCaptionsRow struct {
	MediaPath string          `json:"media_path"`
	Time      sql.NullFloat64 `json:"time"`
	Text      sql.NullString  `json:"text"`
	Title     sql.NullString  `json:"title"`
}

func (q *Queries) SearchCaptions(ctx context.Context, query string) ([]SearchCaptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCaptions, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCaptionsRow{}
	for rows.Next() {
		var i SearchCaptionsRow
		if err := rows.Scan(
			&i.MediaPath,
			&i.Time,
			&i.Text,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMediaFTS = `-- name: SearchMediaFTS :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, mood, bpm, "key", decade, categories, city, country, description, language, webpath, uploader, time_uploaded, time_downloaded, view_count, num_comments, favorite_count, score, upvote_ratio, latitude, longitude FROM media
WHERE rowid IN (
    SELECT rowid FROM media_fts f WHERE f.title MATCH ?1
)
AND time_deleted = 0
LIMIT ?2
`

type SearchMediaFTSParams struct {
	Query string `json:"query"`
	Limit int64  `json:"limit"`
}

func (q *Queries) SearchMediaFTS(ctx context.Context, arg SearchMediaFTSParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, searchMediaFTS, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Mood,
			&i.Bpm,
			&i.Key,
			&i.Decade,
			&i.Categories,
			&i.City,
			&i.Country,
			&i.Description,
			&i.Language,
			&i.Webpath,
			&i.Uploader,
			&i.TimeUploaded,
			&i.TimeDownloaded,
			&i.ViewCount,
			&i.NumComments,
			&i.FavoriteCount,
			&i.Score,
			&i.UpvoteRatio,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMediaCategories = `-- name: UpdateMediaCategories :exec
UPDATE media
SET categories = ?
WHERE path = ?
`

type UpdateMediaCategoriesParams struct {
	Categories sql.NullString `json:"categories"`
	Path       string         `json:"path"`
}

func (q *Queries) UpdateMediaCategories(ctx context.Context, arg UpdateMediaCategoriesParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaCategories, arg.Categories, arg.Path)
	return err
}

const updatePath = `-- name: UpdatePath :exec
UPDATE media
SET path = ?
WHERE path = ?
`

type UpdatePathParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
}

func (q *Queries) UpdatePath(ctx context.Context, arg UpdatePathParams) error {
	_, err := q.db.ExecContext(ctx, updatePath, arg.Path, arg.Path_2)
	return err
}

const updatePlayHistory = `-- name: UpdatePlayHistory :exec
UPDATE media
SET time_last_played = ?,
    time_first_played = COALESCE(time_first_played, ?),
    play_count = COALESCE(play_count, 0) + 1,
    playhead = ?
WHERE path = ?
`

type UpdatePlayHistoryParams struct {
	TimeLastPlayed  sql.NullInt64 `json:"time_last_played"`
	TimeFirstPlayed sql.NullInt64 `json:"time_first_played"`
	Playhead        sql.NullInt64 `json:"playhead"`
	Path            string        `json:"path"`
}

func (q *Queries) UpdatePlayHistory(ctx context.Context, arg UpdatePlayHistoryParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayHistory,
		arg.TimeLastPlayed,
		arg.TimeFirstPlayed,
		arg.Playhead,
		arg.Path,
	)
	return err
}

const upsertMedia = `-- name: UpsertMedia :exec
INSERT INTO media (
    path, title, duration, size, time_created, time_modified,
    type, width, height, fps,
    video_codecs, audio_codecs, subtitle_codecs,
    video_count, audio_count, subtitle_count,
    album, artist, genre, 
    mood, bpm, key, decade, categories, city, country,
    description, language,
    webpath, uploader, time_uploaded, time_downloaded,
    view_count, num_comments, favorite_count, score, upvote_ratio,
    latitude, longitude
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?,
    ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?
)
ON CONFLICT(path) DO UPDATE SET
    title = excluded.title,
    duration = excluded.duration,
    size = excluded.size,
    time_modified = excluded.time_modified,
    type = excluded.type,
    width = excluded.width,
    height = excluded.height,
    fps = excluded.fps,
    video_codecs = excluded.video_codecs,
    audio_codecs = excluded.audio_codecs,
    subtitle_codecs = excluded.subtitle_codecs,
    video_count = excluded.video_count,
    audio_count = excluded.audio_count,
    subtitle_count = excluded.subtitle_count,
    album = excluded.album,
    artist = excluded.artist,
    genre = excluded.genre,
    mood = excluded.mood,
    bpm = excluded.bpm,
    key = excluded.key,
    decade = excluded.decade,
    categories = excluded.categories,
    city = excluded.city,
    country = excluded.country,
    description = excluded.description,
    language = excluded.language,
    webpath = excluded.webpath,
    uploader = excluded.uploader,
    time_uploaded = excluded.time_uploaded,
    time_downloaded = excluded.time_downloaded,
    view_count = excluded.view_count,
    num_comments = excluded.num_comments,
    favorite_count = excluded.favorite_count,
    score = excluded.score,
    upvote_ratio = excluded.upvote_ratio,
    latitude = excluded.latitude,
    longitude = excluded.longitude
`

type UpsertMediaParams struct {
	Path           string          `json:"path"`
	Title          sql.NullString  `json:"title"`
	Duration       sql.NullInt64   `json:"duration"`
	Size           sql.NullInt64   `json:"size"`
	TimeCreated    sql.NullInt64   `json:"time_created"`
	TimeModified   sql.NullInt64   `json:"time_modified"`
	Type           sql.NullString  `json:"type"`
	Width          sql.NullInt64   `json:"width"`
	Height         sql.NullInt64   `json:"height"`
	Fps            sql.NullFloat64 `json:"fps"`
	VideoCodecs    sql.NullString  `json:"video_codecs"`
	AudioCodecs    sql.NullString  `json:"audio_codecs"`
	SubtitleCodecs sql.NullString  `json:"subtitle_codecs"`
	VideoCount     sql.NullInt64   `json:"video_count"`
	AudioCount     sql.NullInt64   `json:"audio_count"`
	SubtitleCount  sql.NullInt64   `json:"subtitle_count"`
	Album          sql.NullString  `json:"album"`
	Artist         sql.NullString  `json:"artist"`
	Genre          sql.NullString  `json:"genre"`
	Mood           sql.NullString  `json:"mood"`
	Bpm            sql.NullInt64   `json:"bpm"`
	Key            sql.NullString  `json:"key"`
	Decade         sql.NullString  `json:"decade"`
	Categories     sql.NullString  `json:"categories"`
	City           sql.NullString  `json:"city"`
	Country        sql.NullString  `json:"country"`
	Description    sql.NullString  `json:"description"`
	Language       sql.NullString  `json:"language"`
	Webpath        sql.NullString  `json:"webpath"`
	Uploader       sql.NullString  `json:"uploader"`
	TimeUploaded   sql.NullInt64   `json:"time_uploaded"`
	TimeDownloaded sql.NullInt64   `json:"time_downloaded"`
	ViewCount      sql.NullInt64   `json:"view_count"`
	NumComments    sql.NullInt64   `json:"num_comments"`
	FavoriteCount  sql.NullInt64   `json:"favorite_count"`
	Score          sql.NullFloat64 `json:"score"`
	UpvoteRatio    sql.NullFloat64 `json:"upvote_ratio"`
	Latitude       sql.NullFloat64 `json:"latitude"`
	Longitude      sql.NullFloat64 `json:"longitude"`
}

func (q *Queries) UpsertMedia(ctx context.Context, arg UpsertMediaParams) error {
	_, err := q.db.ExecContext(ctx, upsertMedia,
		arg.Path,
		arg.Title,
		arg.Duration,
		arg.Size,
		arg.TimeCreated,
		arg.TimeModified,
		arg.Type,
		arg.Width,
		arg.Height,
		arg.Fps,
		arg.VideoCodecs,
		arg.AudioCodecs,
		arg.SubtitleCodecs,
		arg.VideoCount,
		arg.AudioCount,
		arg.SubtitleCount,
		arg.Album,
		arg.Artist,
		arg.Genre,
		arg.Mood,
		arg.Bpm,
		arg.Key,
		arg.Decade,
		arg.Categories,
		arg.City,
		arg.Country,
		arg.Description,
		arg.Language,
		arg.Webpath,
		arg.Uploader,
		arg.TimeUploaded,
		arg.TimeDownloaded,
		arg.ViewCount,
		arg.NumComments,
		arg.FavoriteCount,
		arg.Score,
		arg.UpvoteRatio,
		arg.Latitude,
		arg.Longitude,
	)
	return err
}
