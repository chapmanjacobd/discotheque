// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getMedia = `-- name: GetMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByDuration = `-- name: GetMediaByDuration :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND duration >= ?
  AND duration <= ?
ORDER BY duration DESC
LIMIT ?
`

type GetMediaByDurationParams struct {
	Duration   sql.NullInt64 `json:"duration"`
	Duration_2 sql.NullInt64 `json:"duration_2"`
	Limit      int64         `json:"limit"`
}

func (q *Queries) GetMediaByDuration(ctx context.Context, arg GetMediaByDurationParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByDuration, arg.Duration, arg.Duration_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPath = `-- name: GetMediaByPath :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND path LIKE ?
ORDER BY path
LIMIT ?
`

type GetMediaByPathParams struct {
	Path  string `json:"path"`
	Limit int64  `json:"limit"`
}

func (q *Queries) GetMediaByPath(ctx context.Context, arg GetMediaByPathParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPath, arg.Path, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPathExact = `-- name: GetMediaByPathExact :one
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE path = ?
LIMIT 1
`

func (q *Queries) GetMediaByPathExact(ctx context.Context, path string) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByPathExact, path)
	var i Media
	err := row.Scan(
		&i.Path,
		&i.Title,
		&i.Duration,
		&i.Size,
		&i.TimeCreated,
		&i.TimeModified,
		&i.TimeDeleted,
		&i.TimeFirstPlayed,
		&i.TimeLastPlayed,
		&i.PlayCount,
		&i.Playhead,
		&i.Type,
		&i.Width,
		&i.Height,
		&i.Fps,
		&i.VideoCodecs,
		&i.AudioCodecs,
		&i.SubtitleCodecs,
		&i.VideoCount,
		&i.AudioCount,
		&i.SubtitleCount,
		&i.Album,
		&i.Artist,
		&i.Genre,
		&i.Description,
		&i.Language,
	)
	return i, err
}

const getMediaByPlayCount = `-- name: GetMediaByPlayCount :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND play_count >= ?
  AND play_count <= ?
ORDER BY play_count DESC
LIMIT ?
`

type GetMediaByPlayCountParams struct {
	PlayCount   sql.NullInt64 `json:"play_count"`
	PlayCount_2 sql.NullInt64 `json:"play_count_2"`
	Limit       int64         `json:"limit"`
}

func (q *Queries) GetMediaByPlayCount(ctx context.Context, arg GetMediaByPlayCountParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPlayCount, arg.PlayCount, arg.PlayCount_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaBySize = `-- name: GetMediaBySize :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND size >= ?
  AND size <= ?
ORDER BY size DESC
LIMIT ?
`

type GetMediaBySizeParams struct {
	Size   sql.NullInt64 `json:"size"`
	Size_2 sql.NullInt64 `json:"size_2"`
	Limit  int64         `json:"limit"`
}

func (q *Queries) GetMediaBySize(ctx context.Context, arg GetMediaBySizeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaBySize, arg.Size, arg.Size_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByType = `-- name: GetMediaByType :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND (
    (? AND type LIKE 'video/%')
    OR (? AND type LIKE 'audio/%' AND video_count = 0)
    OR (? AND type LIKE 'image/%')
  )
ORDER BY path
LIMIT ?
`

type GetMediaByTypeParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int64       `json:"limit"`
}

func (q *Queries) GetMediaByType(ctx context.Context, arg GetMediaByTypeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByType,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMedia = `-- name: GetRandomMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
ORDER BY RANDOM()
LIMIT ?
`

func (q *Queries) GetRandomMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getRandomMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiblingMedia = `-- name: GetSiblingMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND path LIKE ?
  AND path != ?
ORDER BY path
LIMIT ?
`

type GetSiblingMediaParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetSiblingMedia(ctx context.Context, arg GetSiblingMediaParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getSiblingMedia, arg.Path, arg.Path_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :one
SELECT
    COUNT(*) as total_count,
    SUM(size) as total_size,
    SUM(duration) as total_duration,
    COUNT(CASE WHEN COALESCE(time_last_played, 0) > 0 THEN 1 END) as watched_count,
    COUNT(CASE WHEN COALESCE(time_last_played, 0) = 0 THEN 1 END) as unwatched_count
FROM media
WHERE time_deleted = 0
`

type GetStatsRow struct {
	TotalCount     int64           `json:"total_count"`
	TotalSize      sql.NullFloat64 `json:"total_size"`
	TotalDuration  sql.NullFloat64 `json:"total_duration"`
	WatchedCount   int64           `json:"watched_count"`
	UnwatchedCount int64           `json:"unwatched_count"`
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.TotalSize,
		&i.TotalDuration,
		&i.WatchedCount,
		&i.UnwatchedCount,
	)
	return i, err
}

const getStatsByType = `-- name: GetStatsByType :many
SELECT
    type,
    COUNT(*) as count,
    SUM(size) as total_size,
    SUM(duration) as total_duration
FROM media
WHERE time_deleted = 0
GROUP BY type
`

type GetStatsByTypeRow struct {
	Type          sql.NullString  `json:"type"`
	Count         int64           `json:"count"`
	TotalSize     sql.NullFloat64 `json:"total_size"`
	TotalDuration sql.NullFloat64 `json:"total_duration"`
}

func (q *Queries) GetStatsByType(ctx context.Context) ([]GetStatsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatsByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatsByTypeRow{}
	for rows.Next() {
		var i GetStatsByTypeRow
		if err := rows.Scan(
			&i.Type,
			&i.Count,
			&i.TotalSize,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedMedia = `-- name: GetUnfinishedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND playhead > 0
  AND playhead < duration * 0.95
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetUnfinishedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnfinishedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnwatchedMedia = `-- name: GetUnwatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND COALESCE(time_last_played, 0) = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetUnwatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnwatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedMedia = `-- name: GetWatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count, album, artist, genre, description, language FROM media
WHERE time_deleted = 0
  AND COALESCE(time_last_played, 0) > 0
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetWatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPlaylist = `-- name: InsertPlaylist :one
INSERT INTO playlists (path, extractor_key, extractor_config)
VALUES (?, ?, ?)
ON CONFLICT(path) DO UPDATE SET
    extractor_key = excluded.extractor_key,
    extractor_config = excluded.extractor_config
RETURNING id
`

type InsertPlaylistParams struct {
	Path            sql.NullString `json:"path"`
	ExtractorKey    sql.NullString `json:"extractor_key"`
	ExtractorConfig sql.NullString `json:"extractor_config"`
}

func (q *Queries) InsertPlaylist(ctx context.Context, arg InsertPlaylistParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertPlaylist, arg.Path, arg.ExtractorKey, arg.ExtractorConfig)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const markDeleted = `-- name: MarkDeleted :exec
UPDATE media
SET time_deleted = ?
WHERE path = ?
`

type MarkDeletedParams struct {
	TimeDeleted sql.NullInt64 `json:"time_deleted"`
	Path        string        `json:"path"`
}

func (q *Queries) MarkDeleted(ctx context.Context, arg MarkDeletedParams) error {
	_, err := q.db.ExecContext(ctx, markDeleted, arg.TimeDeleted, arg.Path)
	return err
}

const searchMediaFTS = `-- name: SearchMediaFTS :many
SELECT m.path, m.title, m.duration, m.size, m.time_created, m.time_modified, m.time_deleted, m.time_first_played, m.time_last_played, m.play_count, m.playhead, m.type, m.width, m.height, m.fps, m.video_codecs, m.audio_codecs, m.subtitle_codecs, m.video_count, m.audio_count, m.subtitle_count, m.album, m.artist, m.genre, m.description, m.language FROM media m
JOIN media_fts f ON m.rowid = f.rowid
WHERE f.path MATCH ?1
  AND m.time_deleted = 0
ORDER BY f.rank
LIMIT ?2
`

type SearchMediaFTSParams struct {
	Query string `json:"query"`
	Limit int64  `json:"limit"`
}

func (q *Queries) SearchMediaFTS(ctx context.Context, arg SearchMediaFTSParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, searchMediaFTS, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
			&i.Album,
			&i.Artist,
			&i.Genre,
			&i.Description,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePath = `-- name: UpdatePath :exec
UPDATE media
SET path = ?
WHERE path = ?
`

type UpdatePathParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
}

func (q *Queries) UpdatePath(ctx context.Context, arg UpdatePathParams) error {
	_, err := q.db.ExecContext(ctx, updatePath, arg.Path, arg.Path_2)
	return err
}

const updatePlayHistory = `-- name: UpdatePlayHistory :exec
UPDATE media
SET time_last_played = ?,
    time_first_played = COALESCE(time_first_played, ?),
    play_count = COALESCE(play_count, 0) + 1,
    playhead = ?
WHERE path = ?
`

type UpdatePlayHistoryParams struct {
	TimeLastPlayed  sql.NullInt64 `json:"time_last_played"`
	TimeFirstPlayed sql.NullInt64 `json:"time_first_played"`
	Playhead        sql.NullInt64 `json:"playhead"`
	Path            string        `json:"path"`
}

func (q *Queries) UpdatePlayHistory(ctx context.Context, arg UpdatePlayHistoryParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayHistory,
		arg.TimeLastPlayed,
		arg.TimeFirstPlayed,
		arg.Playhead,
		arg.Path,
	)
	return err
}

const upsertMedia = `-- name: UpsertMedia :exec
INSERT INTO media (
    path, title, duration, size, time_created, time_modified,
    type, width, height, fps,
    video_codecs, audio_codecs, subtitle_codecs,
    video_count, audio_count, subtitle_count,
    album, artist, genre, description, language
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?, ?
)
ON CONFLICT(path) DO UPDATE SET
    title = excluded.title,
    duration = excluded.duration,
    size = excluded.size,
    time_modified = excluded.time_modified,
    type = excluded.type,
    width = excluded.width,
    height = excluded.height,
    fps = excluded.fps,
    video_codecs = excluded.video_codecs,
    audio_codecs = excluded.audio_codecs,
    subtitle_codecs = excluded.subtitle_codecs,
    video_count = excluded.video_count,
    audio_count = excluded.audio_count,
    subtitle_count = excluded.subtitle_count,
    album = excluded.album,
    artist = excluded.artist,
    genre = excluded.genre,
    description = excluded.description,
    language = excluded.language
`

type UpsertMediaParams struct {
	Path           string          `json:"path"`
	Title          sql.NullString  `json:"title"`
	Duration       sql.NullInt64   `json:"duration"`
	Size           sql.NullInt64   `json:"size"`
	TimeCreated    sql.NullInt64   `json:"time_created"`
	TimeModified   sql.NullInt64   `json:"time_modified"`
	Type           sql.NullString  `json:"type"`
	Width          sql.NullInt64   `json:"width"`
	Height         sql.NullInt64   `json:"height"`
	Fps            sql.NullFloat64 `json:"fps"`
	VideoCodecs    sql.NullString  `json:"video_codecs"`
	AudioCodecs    sql.NullString  `json:"audio_codecs"`
	SubtitleCodecs sql.NullString  `json:"subtitle_codecs"`
	VideoCount     sql.NullInt64   `json:"video_count"`
	AudioCount     sql.NullInt64   `json:"audio_count"`
	SubtitleCount  sql.NullInt64   `json:"subtitle_count"`
	Album          sql.NullString  `json:"album"`
	Artist         sql.NullString  `json:"artist"`
	Genre          sql.NullString  `json:"genre"`
	Description    sql.NullString  `json:"description"`
	Language       sql.NullString  `json:"language"`
}

func (q *Queries) UpsertMedia(ctx context.Context, arg UpsertMediaParams) error {
	_, err := q.db.ExecContext(ctx, upsertMedia,
		arg.Path,
		arg.Title,
		arg.Duration,
		arg.Size,
		arg.TimeCreated,
		arg.TimeModified,
		arg.Type,
		arg.Width,
		arg.Height,
		arg.Fps,
		arg.VideoCodecs,
		arg.AudioCodecs,
		arg.SubtitleCodecs,
		arg.VideoCount,
		arg.AudioCount,
		arg.SubtitleCount,
		arg.Album,
		arg.Artist,
		arg.Genre,
		arg.Description,
		arg.Language,
	)
	return err
}
