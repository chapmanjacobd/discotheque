// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getMedia = `-- name: GetMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByDuration = `-- name: GetMediaByDuration :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND duration >= ?
  AND duration <= ?
ORDER BY duration DESC
LIMIT ?
`

type GetMediaByDurationParams struct {
	Duration   sql.NullInt64 `json:"duration"`
	Duration_2 sql.NullInt64 `json:"duration_2"`
	Limit      int64         `json:"limit"`
}

func (q *Queries) GetMediaByDuration(ctx context.Context, arg GetMediaByDurationParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByDuration, arg.Duration, arg.Duration_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPath = `-- name: GetMediaByPath :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND path LIKE ?
ORDER BY path
LIMIT ?
`

type GetMediaByPathParams struct {
	Path  string `json:"path"`
	Limit int64  `json:"limit"`
}

func (q *Queries) GetMediaByPath(ctx context.Context, arg GetMediaByPathParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPath, arg.Path, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByPlayCount = `-- name: GetMediaByPlayCount :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND play_count >= ?
  AND play_count <= ?
ORDER BY play_count DESC
LIMIT ?
`

type GetMediaByPlayCountParams struct {
	PlayCount   sql.NullInt64 `json:"play_count"`
	PlayCount_2 sql.NullInt64 `json:"play_count_2"`
	Limit       int64         `json:"limit"`
}

func (q *Queries) GetMediaByPlayCount(ctx context.Context, arg GetMediaByPlayCountParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPlayCount, arg.PlayCount, arg.PlayCount_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaBySize = `-- name: GetMediaBySize :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND size >= ?
  AND size <= ?
ORDER BY size DESC
LIMIT ?
`

type GetMediaBySizeParams struct {
	Size   sql.NullInt64 `json:"size"`
	Size_2 sql.NullInt64 `json:"size_2"`
	Limit  int64         `json:"limit"`
}

func (q *Queries) GetMediaBySize(ctx context.Context, arg GetMediaBySizeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaBySize, arg.Size, arg.Size_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByType = `-- name: GetMediaByType :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND (
    (? AND type LIKE 'video/%')
    OR (? AND type LIKE 'audio/%' AND video_count = 0)
    OR (? AND type LIKE 'image/%')
  )
ORDER BY path
LIMIT ?
`

type GetMediaByTypeParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int64       `json:"limit"`
}

func (q *Queries) GetMediaByType(ctx context.Context, arg GetMediaByTypeParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByType,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMedia = `-- name: GetRandomMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
ORDER BY RANDOM()
LIMIT ?
`

func (q *Queries) GetRandomMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getRandomMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiblingMedia = `-- name: GetSiblingMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND path LIKE ?
  AND path != ?
ORDER BY path
LIMIT ?
`

type GetSiblingMediaParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetSiblingMedia(ctx context.Context, arg GetSiblingMediaParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getSiblingMedia, arg.Path, arg.Path_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedMedia = `-- name: GetUnfinishedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND playhead > 0
  AND playhead < duration * 0.95
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetUnfinishedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnfinishedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnwatchedMedia = `-- name: GetUnwatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND time_last_played = 0
ORDER BY path
LIMIT ?
`

func (q *Queries) GetUnwatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getUnwatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedMedia = `-- name: GetWatchedMedia :many
SELECT path, title, duration, size, time_created, time_modified, time_deleted, time_first_played, time_last_played, play_count, playhead, type, width, height, fps, video_codecs, audio_codecs, subtitle_codecs, video_count, audio_count, subtitle_count FROM media
WHERE time_deleted = 0
  AND time_last_played > 0
ORDER BY time_last_played DESC
LIMIT ?
`

func (q *Queries) GetWatchedMedia(ctx context.Context, limit int64) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeleted = `-- name: MarkDeleted :exec
UPDATE media
SET time_deleted = ?
WHERE path = ?
`

type MarkDeletedParams struct {
	TimeDeleted sql.NullInt64 `json:"time_deleted"`
	Path        string        `json:"path"`
}

func (q *Queries) MarkDeleted(ctx context.Context, arg MarkDeletedParams) error {
	_, err := q.db.ExecContext(ctx, markDeleted, arg.TimeDeleted, arg.Path)
	return err
}

const searchMediaFTS = `-- name: SearchMediaFTS :many
SELECT m.path, m.title, m.duration, m.size, m.time_created, m.time_modified, m.time_deleted, m.time_first_played, m.time_last_played, m.play_count, m.playhead, m.type, m.width, m.height, m.fps, m.video_codecs, m.audio_codecs, m.subtitle_codecs, m.video_count, m.audio_count, m.subtitle_count FROM media m
JOIN media_fts f ON m.rowid = f.rowid
WHERE f.path MATCH ?1
  AND m.time_deleted = 0
ORDER BY f.rank
LIMIT ?2
`

type SearchMediaFTSParams struct {
	Query string `json:"query"`
	Limit int64  `json:"limit"`
}

func (q *Queries) SearchMediaFTS(ctx context.Context, arg SearchMediaFTSParams) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, searchMediaFTS, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Duration,
			&i.Size,
			&i.TimeCreated,
			&i.TimeModified,
			&i.TimeDeleted,
			&i.TimeFirstPlayed,
			&i.TimeLastPlayed,
			&i.PlayCount,
			&i.Playhead,
			&i.Type,
			&i.Width,
			&i.Height,
			&i.Fps,
			&i.VideoCodecs,
			&i.AudioCodecs,
			&i.SubtitleCodecs,
			&i.VideoCount,
			&i.AudioCount,
			&i.SubtitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePath = `-- name: UpdatePath :exec
UPDATE media
SET path = ?
WHERE path = ?
`

type UpdatePathParams struct {
	Path   string `json:"path"`
	Path_2 string `json:"path_2"`
}

func (q *Queries) UpdatePath(ctx context.Context, arg UpdatePathParams) error {
	_, err := q.db.ExecContext(ctx, updatePath, arg.Path, arg.Path_2)
	return err
}

const updatePlayHistory = `-- name: UpdatePlayHistory :exec
UPDATE media
SET time_last_played = ?,
    time_first_played = COALESCE(time_first_played, ?),
    play_count = COALESCE(play_count, 0) + 1,
    playhead = ?
WHERE path = ?
`

type UpdatePlayHistoryParams struct {
	TimeLastPlayed  sql.NullInt64 `json:"time_last_played"`
	TimeFirstPlayed sql.NullInt64 `json:"time_first_played"`
	Playhead        sql.NullInt64 `json:"playhead"`
	Path            string        `json:"path"`
}

func (q *Queries) UpdatePlayHistory(ctx context.Context, arg UpdatePlayHistoryParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayHistory,
		arg.TimeLastPlayed,
		arg.TimeFirstPlayed,
		arg.Playhead,
		arg.Path,
	)
	return err
}
